## Deferred
	suspend fun valueAsync(): Deferred<String> = coroutineScope {
        val deferred = CompletableDeferred<String>()
        launch {
            delay(1000)
            if (Random.nextBoolean()) {
                deferred.complete("OK")
            } else {
                deferred.completeExceptionally(
                    RuntimeException()
                )
            }
        }
        deferred
    }
	runBlocking {
 		val value = valueAsync()
 		println(value.await())
	}

## Barrier
- The Barrier design pattern enables us to pause and wait for multiple concurrent tasks to finish before moving on.
	data class FavoriteCharacter(
	 	val name: String,
	 	val catchphrase: String,
	 	val picture: ByteArray = Random.nextBytes(42)
	)
	fun CoroutineScope.getCatchphraseAsync(characterName: String) = async { … }
	fun CoroutineScope.getPictureAsync(characterName: String) = async { … }
	suspend fun fetchFavoriteCharacter(name: String) = coroutineScope {
	 	val catchphrase = getCatchphraseAsync(name)
 		val picture = getPictureAsync(name)
 		// The await() calls to the data class constructor, 
 		// we initiate both coroutines simultaneously and wait for their completion as intended
 		FavoriteCharacter(name, catchphrase.await(), picture.await())
	}

	val characters: List<Deferred<FavoriteCharacter>> = listOf(
 		Me.getFavoriteCharacter(),
	 	Taylor.getFavoriteCharacter(),
	 	Michael.getFavoriteCharacter()
	)
	try {
 		println(characters.awaitAll()) // Will be wait for all characters
 	} catch (e: RuntimeException) {
 		println("Caught exception: ${e.message}")
 	}
	
## Pipeline
	private fun CoroutineScope.producePages() = produce {
        for (p in listOf("Cool stuff", "Even more stuff")) {
            println("Produce Page sent")
            send(p)
        }
    }
	private fun CoroutineScope.produceDoc(pages: ReceiveChannel<String>) = produce {
        for (p in pages) {
            println("Produce Doc sent")
            send(Document(p))
        }
    }
	private fun CoroutineScope.produceTitles(parsedPages: ReceiveChannel<Document>) = produce {
        for (page in parsedPages) {
            println("Produce Title sent")
            send(page.getElementsByTagName("h1"))
        }
    }
	runBlocking {
	 	val pagesProducer = producePages() 				// Run first
	 	val docProducer = produceDoc(pagesProducer)		// Run second
	 	val titleProducer = produceTitles(docProducer)	// Run third
	 	titleProducer.consumeEach {
	 		println(it)									// => Synchronously
	 	}
	}

## Fan-Out
- The purpose of the Fan-Out design pattern is to divide the workload among multiple concurrent processors, or workers, efficiently.
	fun CoroutineScope.generateWork() = produce {
	 	for (i in 1..10_000) {
	 		send("page$i")
	 	}
	 	close()
	}
	fun CoroutineScope.doWork(
	 	id: Int,
	 	channel: ReceiveChannel<String>
	) = launch(Dispatchers.Default) {
	 	for (p in channel) {
	 		println("Worker $id processed $p")
	 	}
	}
	val workChannel = generateWork()
	val workers = List(10) { id ->
 		doWork(id, workChannel)
	}
	Consonle
		...
		> Worker 4 processed page9994
		> Worker 8 processed page9993
		> Worker 3 processed page9992
		> Worker 6 processed page9987
	- Note that no two workers receive the same message, and the messages are not printed in the order they were sent. 
	- Load balancing is a critical aspect of the Fan-Out design pattern. It ensures that the workload is evenly and efficiently 
	distributed across the available resources, preventing situations where some workers are overloaded while others remain underutilized.

## Fan-In
- The objective of the Fan-In design pattern is to consolidate results generated by multiple workers.
	private fun CoroutineScope.doWorkAsync(
	 	channel: ReceiveChannel<String>,
	 	resultChannel: Channel<String>
	) = async(Dispatchers.Default) {
	 	for (p in channel) {
	 		resultChannel.send(p)
	 	}	
	}
	runBlocking {
	 	val workChannel = generateWork()
	 	val resultChannel = Channel<String>()
	 	List(10) {
	 		doWorkAsync(workChannel, resultChannel)
	 	}
	 	resultChannel.consumeEach {
	 		println(it) // Handle result synchonously
	 	}
	}

## Sidekick
- The Sidekick design pattern enables us to delegate some tasks from our primary worker to a
secondary worker.
    private fun CoroutineScope.batman() = actor<String> {
        for (c in channel) {
            println("Batman is dealing with $c")
            delay(200)
        }
    }
    
    private fun CoroutineScope.robin() = actor<String> {
        for (c in channel) {
            println("Robin is dealing with $c")
            delay(200)
        }
    }
	
	lifecycleScope.launch {
        val robin = robin()
        val batman = batman()
        for (villain in listOf("Joker", "Bane", "Penguin", "Riddler", "Killer")) {
            val result = select<Pair<String, String>> {
                robin.onSend(villain) {
                    "Robin" to villain
                }
                batman.onSend(villain) {
                    "Batman" to villain
                }
            }
            println(result)
        }
    }

## Racing
- The Racing design pattern is a concurrency pattern that involves running multiple tasks that
produce the same type of data concurrently and selecting the result from the task that completes
first, discarding the results from the other tasks.
- Can Use "SelectUnbiased" for this pattern, but it is not 100% similar as the theory.














